"""
Chat Engine CORRIGIDO - Vers√£o definitiva funcionando
"""
import os
import sys
import json
import uuid
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS
from datetime import datetime, timezone
import requests

# Configura√ß√£o
class Config:
    PROJECT_ID = 'flower-ai-generator'
    BIGQUERY_DATASET = 'saas_chat_generator'
    CLAUDE_MODEL = 'claude-sonnet-4-20250514'

# Flask app
app = Flask(__name__)
CORS(app, origins=["*"])

# CORRE√á√ÉO: Cache da API key para evitar m√∫ltiplas chamadas
_cached_api_key = None

def get_claude_api_key():
    """Buscar API key com cache e error handling robusto"""
    global _cached_api_key
    
    if _cached_api_key:
        return _cached_api_key
    
    try:
        print("üîç Buscando Claude API key...")
        from google.cloud import secretmanager
        
        client = secretmanager.SecretManagerServiceClient()
        name = f"projects/{Config.PROJECT_ID}/secrets/claude-api-key/versions/latest"
        
        response = client.access_secret_version(request={"name": name})
        api_key = response.payload.data.decode("UTF-8").strip()
        
        # Valida√ß√£o robusta
        if not api_key:
            print("‚ùå API key vazia")
            return None
            
        if not api_key.startswith('sk-ant-api03-'):
            print(f"‚ùå API key com formato inv√°lido: {api_key[:20]}...")
            return None
            
        if len(api_key) < 50:
            print(f"‚ùå API key muito curta: {len(api_key)} caracteres")
            return None
        
        # Cache e log de sucesso
        _cached_api_key = api_key
        print(f"‚úÖ API key obtida com sucesso: {api_key[:20]}...{api_key[-10:]}")
        return api_key
        
    except Exception as e:
        print(f"‚ùå ERRO ao buscar API key: {e}")
        return None

def get_bigquery_client():
    """Lazy import do BigQuery"""
    try:
        from google.cloud import bigquery
        return bigquery.Client(project=Config.PROJECT_ID)
    except Exception as e:
        print(f"‚ö†Ô∏è BigQuery n√£o dispon√≠vel: {e}")
        return None

def get_chat_by_id(chat_id):
    """Buscar chat por ID com fallback"""
    try:
        client = get_bigquery_client()
        if not client:
            # Fallback para teste
            return {
                'chat_id': chat_id, 
                'chat_name': 'Chat Teste', 
                'system_prompt': 'Voc√™ √© um assistente √∫til.',
                'claude_model': 'claude-3-haiku-20240307',
                'max_tokens': 1500
            }
        
        from google.cloud import bigquery
        query = f"""
        SELECT * FROM `{Config.PROJECT_ID}.{Config.BIGQUERY_DATASET}.chats`
        WHERE chat_id = @chat_id
        """
        
        job_config = bigquery.QueryJobConfig(
            query_parameters=[bigquery.ScalarQueryParameter("chat_id", "STRING", chat_id)]
        )
        
        query_job = client.query(query, job_config=job_config)
        results = list(query_job.result())
        
        return dict(results[0]) if results else None
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao buscar chat: {e}")
        # Fallback
        return {
            'chat_id': chat_id, 
            'chat_name': 'Chat Teste', 
            'system_prompt': 'Voc√™ √© um assistente √∫til.',
            'claude_model': 'claude-3-haiku-20240307',
            'max_tokens': 1500
        }

def save_message(chat_id, conversation_id, role, content, source='web', tokens_used=0, response_time_ms=0):
    """Salvar mensagem com error handling"""
    try:
        client = get_bigquery_client()
        if not client:
            print("‚ö†Ô∏è BigQuery n√£o dispon√≠vel, pulando save_message")
            return False
            
        message_data = {
            'message_id': str(uuid.uuid4()),
            'chat_id': chat_id,
            'conversation_id': conversation_id,
            'role': role,
            'content': content,
            'source': source,
            'source_phone': None,
            'tokens_used': tokens_used,
            'response_time_ms': response_time_ms,
            'timestamp': datetime.now(timezone.utc).isoformat()
        }
        
        table_ref = f"{Config.PROJECT_ID}.{Config.BIGQUERY_DATASET}.messages"
        errors = client.insert_rows_json(table_ref, [message_data])
        
        return len(errors) == 0
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao salvar mensagem: {e}")
        return False

def send_claude_message(messages, model="claude-3-haiku-20240307", max_tokens=1500):
    """VERS√ÉO CORRIGIDA - Enviar para Claude"""
    try:
        # CORRE√á√ÉO: Usar fun√ß√£o robusta para API key
        api_key = get_claude_api_key()
        
        # CORRE√á√ÉO: Error handling espec√≠fico e claro
        if not api_key:
            return {"error": "Erro ao obter Claude API key do Secret Manager"}
        
        headers = {
            "Content-Type": "application/json",
            "x-api-key": api_key,
            "anthropic-version": "2023-06-01"
        }
        
        data = {
            "model": model,
            "max_tokens": max_tokens,
            "messages": messages
        }
        
        print(f"üì§ Enviando para Claude: {model}")
        response = requests.post(
            "https://api.anthropic.com/v1/messages", 
            headers=headers, 
            json=data, 
            timeout=30
        )
        
        print(f"üì• Claude response status: {response.status_code}")
        
        if response.status_code == 200:
            result = response.json()
            print("‚úÖ Claude respondeu com sucesso!")
            return result
        else:
            error_msg = f"Claude API error {response.status_code}: {response.text}"
            print(f"‚ùå {error_msg}")
            return {"error": error_msg}
            
    except Exception as e:
        error_msg = f"Erro na requisi√ß√£o para Claude: {str(e)}"
        print(f"‚ùå {error_msg}")
        return {"error": error_msg}

# ROUTES
@app.route('/')
def index():
    return jsonify({
        'status': 'Chat Engine CORRIGIDO funcionando!',
        'version': '3.0.0-fixed',
        'timestamp': datetime.now().isoformat(),
        'claude_api_status': 'Checking...'
    })

@app.route('/health')
def health():
    """Health check com verifica√ß√£o da Claude API"""
    try:
        # Testar Claude API
        api_key = get_claude_api_key()
        claude_status = "OK" if api_key else "ERROR"
        
        return jsonify({
            'status': 'healthy',
            'service': 'chat-engine-fixed',
            'claude_api': claude_status,
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e)
        }), 500

@app.route('/chat/<chat_id>')
def chat_interface(chat_id):
    try:
        chat = get_chat_by_id(chat_id)
        if not chat:
            return render_template('chat_not_found.html'), 404
        return render_template('chat_interface.html', chat=chat)
    except Exception as e:
        return f"<h1>Erro</h1><p>Chat: {str(e)}</p>", 404

@app.route('/api/chat/<chat_id>/info', methods=['GET'])
def get_chat_info(chat_id):
    try:
        chat = get_chat_by_id(chat_id)
        if not chat:
            return jsonify({'success': False, 'error': 'Chat n√£o encontrado'}), 404
        
        return jsonify({
            'success': True,
            'chat': chat,
            'user': {'full_name': 'Usu√°rio', 'plan': 'free'}
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/chat/<chat_id>/send', methods=['POST'])
def send_message_route(chat_id):
    """ROTA CORRIGIDA - Enviar mensagem"""
    try:
        print(f"üîÑ Processando mensagem para chat {chat_id}")
        
        data = request.get_json()
        user_message = data.get('message', '').strip()
        conversation_id = data.get('conversation_id', str(uuid.uuid4()))
        
        if not user_message:
            return jsonify({'success': False, 'error': 'Mensagem vazia'}), 400
        
        # Buscar chat
        chat = get_chat_by_id(chat_id)
        if not chat:
            return jsonify({'success': False, 'error': 'Chat n√£o encontrado'}), 404
        
        print(f"üìù Chat encontrado: {chat['chat_name']}")
        
        # Salvar mensagem do usu√°rio
        save_message(chat_id, conversation_id, 'user', user_message, 'web')
        
        # Preparar mensagens para Claude
        claude_messages = [
            {"role": "user", "content": f"Sistema: {chat.get('system_prompt', 'Voc√™ √© um assistente √∫til.')}"},
            {"role": "assistant", "content": "Entendido. Estou pronto para ajudar."},
            {"role": "user", "content": user_message}
        ]
        
        print("ü§ñ Enviando para Claude...")
        start_time = datetime.now()
        
        # CORRE√á√ÉO: Usar fun√ß√£o corrigida
        claude_response = send_claude_message(
            messages=claude_messages,
            model=chat.get('claude_model', 'claude-3-haiku-20240307'),
            max_tokens=chat.get('max_tokens', 1500)
        )
        
        response_time = int((datetime.now() - start_time).total_seconds() * 1000)
        
        # CORRE√á√ÉO: Error handling mais espec√≠fico
        if 'error' in claude_response:
            print(f"‚ùå Erro do Claude: {claude_response['error']}")
            return jsonify({
                'success': False, 
                'error': claude_response['error']
            }), 500
        
        # Extrair resposta
        if 'content' not in claude_response or not claude_response['content']:
            return jsonify({
                'success': False,
                'error': 'Resposta inv√°lida do Claude'
            }), 500
            
        assistant_message = claude_response['content'][0]['text']
        tokens_used = claude_response.get('usage', {}).get('output_tokens', 0)
        
        print(f"‚úÖ Claude respondeu: {assistant_message[:50]}...")
        
        # Salvar resposta
        save_message(chat_id, conversation_id, 'assistant', assistant_message, 
                    'web', tokens_used, response_time)
        
        return jsonify({
            'success': True,
            'message': assistant_message,
            'conversation_id': conversation_id,
            'tokens_used': tokens_used,
            'response_time_ms': response_time
        })
        
    except Exception as e:
        error_msg = f'Erro interno: {str(e)}'
        print(f"‚ùå {error_msg}")
        return jsonify({'success': False, 'error': error_msg}), 500

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint n√£o encontrado'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Erro interno do servidor'}), 500

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8080))
    print("üöÄ Chat Engine CORRIGIDO iniciando...")
    print(f"üîë Testando Claude API key...")
    
    # Teste inicial
    api_key = get_claude_api_key()
    if api_key:
        print("‚úÖ Claude API key OK!")
    else:
        print("‚ùå Problema com Claude API key")
    
    app.run(host='0.0.0.0', port=port)
